- name: Déployer les VMs locales avec IP statique
  hosts: hypervisors
  become: yes
  gather_facts: no
  collections:
    - community.libvirt
  tasks:
    - name: Installer package
      become: yes
      package:
        name:
          - ufw
        state: present
    - name: Construire la liste des VMs depuis l'inventory
      set_fact:
        vms: |
          {% set list = [] %}
          {% for host in groups['vms'] %}
          {%   set ip = hostvars[host].ansible_host | default(hostvars[host]['ansible_host']) %}
          {%   if not ip %}
          {%       print "ERREUR: Pas d'IP trouvée pour " ~ host %}
          {%   endif %}
          {%   set _ = list.append({
                'name': host,
                'memory': hostvars[host]['memory'],
                'vcpus': hostvars[host]['vcpus'],
                'mac': hostvars[host]['mac'],
                'ip': ip,
                'disk_size': hostvars[host]['disk_size'] | default('20G')
              }) %}
          {% endfor %}
          {{ list }}

    - name: Vérifier que toutes les VMs ont une IP
      fail:
        msg: "L'adresse IP est manquante pour la VM {{ item.name }}. Vérifiez votre inventory."
      when: item.ip is not defined or item.ip == ""
      loop: "{{ vms }}"

    - name: 1. Définir le réseau libvirt (XML uniquement)
      community.libvirt.virt_net:
        name: smb-net
        command: define
        xml: |
          <network>
            <name>smb-net</name>
            <bridge name="virbr1"/>
            <forward mode="nat"/>
            <dns>
              <forwarder addr='1.1.1.1'/>
            </dns>
            <ip address="192.168.100.1" netmask="255.255.255.0">
              <dhcp>
              <range start='192.168.100.2' end='192.168.100.199'/>
              {% for vm in vms %}
                <host mac='{{ vm.mac }}' ip='{{ vm.ip }}' name='{{ vm.name }}'/>
              {% endfor %}
              </dhcp>
            </ip>
          </network>

    - name: 2. Activer et démarrer le réseau
      community.libvirt.virt_net:
        name: smb-net
        state: active
        autostart: yes

    - name: Créer le répertoire pour chaque VM
      file:
        path: "{{ vm_images_dir }}/{{ item.name }}"
        state: directory
        mode: '0755'
      loop: "{{ vms }}"

    - name: Copier et renommer l'image de base pour chaque VM
      command: >
        qemu-img create -f qcow2 -b {{ vm_images_dir }}/{{ base_image }} -F qcow2 {{ vm_images_dir }}/{{ item.name }}/{{ item.name }}.qcow2
      loop: "{{ vms }}"
      args:
        creates: "{{ vm_images_dir }}/{{ item.name }}/{{ item.name }}.qcow2"


# 1. On récupère les infos du disque avec l'option -U (Force Share)
    # Cela permet de lire les infos même si la VM utilise le disque
    - name: "CHECK: Récupérer la taille actuelle des disques"
      command: "qemu-img info -U --output=json {{ vm_images_dir }}/{{ item.name }}/{{ item.name }}.qcow2"
      register: current_disk_info
      changed_when: false
      loop: "{{ vms }}"

    # 2. On applique le redimensionnement UNIQUEMENT si nécessaire
    - name: Appliquer le redimensionnement du disque
      shell: |
        # On vérifie si la VM tourne (state 'running') via virsh
        vm_state=$(virsh domstate {{ item.0.name }} 2>/dev/null || echo "shut off")

        if [ "$vm_state" = "running" ]; then
            # Cas 1 : VM allumée -> virsh blockresize (A chaud)
            echo "VM is running, using virsh blockresize..."
            virsh blockresize {{ item.0.name }} {{ vm_images_dir }}/{{ item.0.name }}/{{ item.0.name }}.qcow2 {{ item.0.disk_size }}
        else
            # Cas 2 : VM éteinte -> qemu-img resize (A froid)
            echo "VM is stopped, using qemu-img resize..."
            qemu-img resize {{ vm_images_dir }}/{{ item.0.name }}/{{ item.0.name }}.qcow2 {{ item.0.disk_size }}
        fi
      loop: "{{ vms | zip(current_disk_info.results) | list }}"
      register: resize_output
      
      # CONDITION DE DÉCLENCHEMENT :
      # On compare la taille virtuelle actuelle (en bytes) avec la cible (convertie en bytes)
      # Le filtre 'human_to_bytes' gère "50G" -> 53687091200
      when: >
        (item.1.stdout | from_json)['virtual-size'] < (item.0.disk_size | human_to_bytes)
      
      changed_when: "'resized' in resize_output.stdout or 'Block device' in resize_output.stdout"
      
    - name: Définir les VMs
      community.libvirt.virt:
        name: "{{ item.name }}"
        command: define
        xml: |
          <domain type='kvm'>
            <name>{{ item.name }}</name>
            <memory unit='KiB'>{{ item.memory * 1024 }}</memory>
            <vcpu placement='static'>{{ item.vcpus }}</vcpu>
            <os>
              <type arch='x86_64'>hvm</type>
              <boot dev='hd'/>
            </os>
            <devices>
              <disk type='file' device='disk'>
                <driver name='qemu' type='qcow2'/>
                <source file='{{ vm_images_dir }}/{{ item.name }}/{{ item.name }}.qcow2'/>
                <target dev='vda' bus='virtio'/>
              </disk>
              <interface type='network'>
                <source network='smb-net'/>
                <mac address='{{ item.mac }}'/>
                <model type='e1000'/>
              </interface>
              <graphics type='vnc' port='-1' listen='0.0.0.0'/>
              <serial type='pty'>
                <target port='0'/>
              </serial>
              <console type='pty'>
                <target type='serial' port='0'/>
              </console>
            </devices>
          </domain>
        autostart: true
      loop: "{{ vms }}"

    - name: Démarrer les VMs
      community.libvirt.virt:
        name: "{{ item.name }}"
        state: running
      loop: "{{ vms }}"

    