---
- name: Pr√©parer tous les n≈ìuds du cluster (Base System)
  hosts: k3s_cluster
  become: true
  tags: ['k3s_base']
  roles:
    - k3s_base

- name: Installer K3s sur les control-plane (HA avec embedded etcd)
  hosts: k3s_control_plane
  become: true
  serial: 1 
  tags: ['k3s', 'k3s_server']
  roles:
    - k3s_server

- name: Installer K3s sur les workers
  hosts: k3s_workers
  become: true
  tags: ['k3s', 'k3s_agent']
  roles:
    - k3s_agent

- name: D√©ployer MetalLB (Load Balancer)
  hosts: k3s_control_plane[0]
  become: true
  tags: ['metallb']
  roles:
    - metallb

- name: D√©ployer Traefik (Ingress Controller)
  hosts: k3s_control_plane[0]
  become: true
  tags: ['traefik']
  roles:
    - traefik

- name: D√©ployer Cert-Manager et PKI
  hosts: k3s_control_plane[0]
  become: true
  tags: ['certmanager']
  roles:
    - certmanager

- name: D√©ployer Longhorn (Stockage distribu√©)
  hosts: k3s_control_plane[0]
  become: true
  tags: ['longhorn']
  roles:
    - longhorn

- name: D√©ployer Kubernetes Dashboard
  hosts: k3s_control_plane[0]
  become: true
  tags: ['kube_dashboard', 'dashboard']
  roles:
    - kube_dashboard

- name: Configuration LDAP (LLDAP)
  hosts: k3s_control_plane[0]
  become: true
  tags: ['ldap', 'lldap']
  roles:
    - lldap

- name: Configuration Bastion (Teleport)
  hosts: k3s_control_plane[0]
  become: true
  tags: ['bastion', 'teleport']
  roles:
    - teleport

- name: Expose Dashboard and Longhorn via MetalLB
  hosts: k3s_control_plane[0]
  become: true
  tags: ['expose_services']
  tasks:
    - name: Create LB for Kubernetes Dashboard
      ansible.builtin.shell: |
        cat <<EOF | k3s kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: kubernetes-dashboard-lb
          namespace: kubernetes-dashboard
          labels:
            k8s-app: kubernetes-dashboard
        spec:
          type: LoadBalancer
          ports:
            - port: 443
              targetPort: 8443
              protocol: TCP
              name: https
          selector:
            k8s-app: kubernetes-dashboard
        EOF
      register: dashboard_lb
      changed_when: "'created' in dashboard_lb.stdout or 'configured' in dashboard_lb.stdout"

    - name: Create LB for Longhorn UI
      ansible.builtin.shell: |
        cat <<EOF | k3s kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: longhorn-frontend-lb
          namespace: longhorn-system
          labels:
            app: longhorn-ui
        spec:
          type: LoadBalancer
          ports:
            - port: 80
              targetPort: 8000
              protocol: TCP
              name: http
          selector:
            app: longhorn-ui
        EOF
      register: longhorn_lb
      changed_when: "'created' in longhorn_lb.stdout or 'configured' in longhorn_lb.stdout"

    - name: Wait for MetalLB IP attribution
      ansible.builtin.command: |
        k3s kubectl get svc -n kubernetes-dashboard kubernetes-dashboard-lb -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
      register: dashboard_ip
      until: dashboard_ip.stdout != ""
      retries: 20
      delay: 5
      changed_when: false

    - name: Get Longhorn IP
      ansible.builtin.command: |
        k3s kubectl get svc -n longhorn-system longhorn-frontend-lb -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
      register: longhorn_ip
      until: longhorn_ip.stdout != ""
      retries: 20
      delay: 5
      changed_when: false

    - name: Get token Dashboard
      ansible.builtin.slurp:
        src: /root/dashboard-admin-token.txt
      register: dashboard_token
      failed_when: false

- name: R√©cup√©rer le Kubeconfig (Pour usage via VPN)
  hosts: k3s_control_plane[0]
  become: yes               
  gather_facts: no          
  tags: ['kubeconfig']
  
  tasks:
    - name: R√©cup√©rer le fichier kubeconfig (K3s)
      ansible.builtin.fetch:
        src: /etc/rancher/k3s/k3s.yaml
        dest: ../kubeconfig_cluster
        flat: yes

    - name: Remplacer 127.0.0.1 par l'IP interne du VPN (192.168.100.200)
      ansible.builtin.replace:
        path: ../kubeconfig_cluster
        regexp: '127\.0\.0\.1'
        replace: "{{ ansible_host }}" 
      delegate_to: localhost
      become: no

    - name: "INFO: R√©cup√©rer la liste des Ingress (Noms de domaine)"
      become: yes
      ansible.builtin.command: k3s kubectl get ingress -A -o json
      register: k8s_ingress_raw
      changed_when: false

    - name: "INFO: R√©cup√©rer la liste des LoadBalancers (IPs directes)"
      become: yes
      ansible.builtin.command: k3s kubectl get svc -A -o json
      register: k8s_svc_raw
      changed_when: false

    - name: "R√âCAPITULATIF DES ACC√àS AU CLUSTER"
      ansible.builtin.debug:
        msg:
          - "üöÄ SERVICES ACCESSIBLES :"
          - "---------------------------------------------------"
          - "üåê PAR DOMAINE (Ingress Traefik) :"
          - "{{ k8s_ingress_raw.stdout | from_json | json_query(ingress_query) | list }}"
          - "---------------------------------------------------"
          - "üîå PAR IP DIRECTE (MetalLB) :"
          - "{{ k8s_svc_raw.stdout | from_json | json_query(lb_query) | list }}"
          - "---------------------------------------------------"
      vars:
        ingress_query: "items[*].spec.rules[*].host | []"
        lb_query: "items[?spec.type=='LoadBalancer'].{Service: metadata.name, Namespace: metadata.namespace, IP: status.loadBalancer.ingress[0].ip}"

    - name: "INFO: R√©cup√©rer la liste des IngressRoutes (Traefik CRD)"
      become: yes
      ansible.builtin.command: k3s kubectl get ingressroute -A -o json
      register: k8s_ingressroute_raw
      changed_when: false

    - name: "R√âCAPITULATIF DES ROUTES TRAEFIK (CRD)"
      ansible.builtin.debug:
        msg:
          - "üöÄ ROUTES TRAEFIK D√âTECT√âES :"
          - "---------------------------------------------------"
          - "{{ k8s_ingressroute_raw.stdout | from_json | json_query(ingressroute_query) }}"
          - "---------------------------------------------------"
      vars:
        # Cette requ√™te extrait le Namespace, le Nom de la route et la r√®gle de matching (Host, Path, etc.)
        ingressroute_query: "items[*].{Namespace: metadata.namespace, Name: metadata.name, MatchRules: spec.routes[*].match}"